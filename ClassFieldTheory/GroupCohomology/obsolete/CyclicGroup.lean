-- import ClassFieldTheory.GroupCohomology._03_LeftRegular

-- noncomputable section cyclicGroup
-- /-
-- In this section `G` is a cyclic group, finite or infinite, generated by an element `gen`.
-- We define a map `diff₁ : leftRegular R G ⟶ leftRegular R G` to be the morphism taking `of 1`
-- to `of 1 - of gen`. We prove:

-- 1. the image of `diff₁` is equal to the kernel of the augmentationma map
-- `ε : leftRegular R G ⟶ trivial R G R`.
-- 2. if `diff₁ v = 0` then all the coefficients of `v` are equal.
-- -/
-- variable {R G : Type} [Group G] [IsCyclic G] [CommRing R]

-- open Classical Finsupp IsCyclic CategoryTheory.ConcreteCategory
-- open Rep hiding of
-- open scoped CategoryTheory BigOperators

-- /--
-- `gen : G` is the generator of a cyclic group `G`
-- -/
-- abbrev IsCyclic.gen : G := exists_generator.choose

-- /--
-- Every element of a cyclic group `G` is a power of the generator `gen`.
-- -/
-- lemma IsCyclic.gen_spec (g : G) : ∃ n : ℤ, IsCyclic.gen ^ n = g :=
--   IsCyclic.exists_generator.choose_spec g

-- namespace Rep.leftRegular

-- variable (R G)
-- /--
-- Given a cyclic group `G` generated by `gen`,
-- `diff₁` is the map `leftRegular ℤ G` to itself, taking `of g` to `of g - of (g * gen)`.
-- -/
-- def diff₁ : leftRegular R G ⟶ leftRegular R G :=
--     (leftRegularHomEquiv (leftRegular R G)).symm (of 1 - of gen)

-- variable {R G}

-- @[simp]
-- lemma diff₁_of_one : diff₁ R G (of 1) = of 1 - of gen := by
--   have := leftRegularHomEquiv_apply (leftRegular R G) (diff₁ R G)
--   simp only [diff₁, LinearEquiv.apply_symm_apply] at this
--   exact this.symm

-- lemma diff₁_of (g : G) : diff₁ R G (of g) = of g - of (g * gen) :=
-- by
--   rw [of_eq_ρReg_of_one, hom_comm_apply', diff₁_of_one, map_sub, ←ρReg_apply_of]

-- @[simp] theorem ε_comp_diff₁ : diff₁ R G ≫ ε R G = 0 := by
--   apply Hom.ext
--   rw [Rep.comp_apply, diff₁_of, map_sub, ε_of, ε_of, sub_self, zero_apply]


-- /-
-- For any `g : G`, the element `of g - of 1` of the left regular representation is in the image of
-- `diff₁`. This is a step on the way to proving that the image of `diff₁` is equal to the kernel of
-- `ε`.
-- -/
-- lemma of_sub_of_one_mem_range_diff₁ (g : G) :
--     of g - of 1 ∈ LinearMap.range (diff₁ R G).hom.hom := by
--   obtain ⟨n,rfl⟩ := IsCyclic.gen_spec g
--   cases n with
--   | ofNat n =>
--     induction n with
--     | zero =>
--       use 0
--       simp
--     | succ n ih =>
--       obtain ⟨w,hw⟩ := ih
--       use ρReg gen w - of 1
--       rw [Int.ofNat_eq_natCast, zpow_natCast] at hw
--       rw [Int.ofNat_eq_natCast, zpow_natCast, map_sub, hom_comm_apply, hw, map_sub, ρReg_apply_of,
--         ρReg_apply_of, pow_succ', hom_apply, diff₁_of_one, mul_one, sub_sub_sub_cancel_right]
--   | negSucc n =>
--     simp only [zpow_negSucc]
--     induction n with
--     | zero =>
--       use of gen⁻¹
--       rw [hom_apply, diff₁_of, inv_mul_cancel, zero_add, pow_one]
--     | succ n ih =>
--       obtain ⟨w,hw⟩ := ih
--       rw [hom_apply] at hw
--       use ρReg gen⁻¹ w + of gen⁻¹
--       rw [map_add, hom_apply, hom_apply, diff₁_of, hom_comm_apply', ←ρReg, hw, map_sub,
--         ρReg_apply_of, ←of_eq_ρReg_of_one, inv_mul_cancel, sub_add_sub_cancel]
--       group

-- /--
-- The sequence `leftRegular R G ⟶ leftRegular R G ⟶ trivial R G R` is exact,
-- where the first map is `diff₁` and the second is `ε`.
-- -/
-- theorem exact_ε_diff₁ : LinearMap.ker (ε R G).hom.hom = LinearMap.range (diff₁ R G).hom.hom :=
-- by
--   apply eq_of_le_of_le
--   · intro v hv
--     rw [LinearMap.mem_ker, hom_apply, ε_eq_sum_coeff] at hv
--     let pre (g : G) : leftRegular R G :=
--       (of_sub_of_one_mem_range_diff₁ g).choose
--     have pre_spec (g : G) : diff₁ R G (pre g) = of g - of 1 :=
--       (of_sub_of_one_mem_range_diff₁ g).choose_spec
--     let S := (coeff v).support
--     use ∑ g ∈ S, coeff v g • pre g
--     rw [map_sum]
--     conv => {
--       left
--       right
--       intro x
--       rw [map_smul, hom_apply, pre_spec, smul_sub]
--     }
--     rw [Finset.sum_sub_distrib, ←Finset.sum_smul, hv, zero_smul, sub_zero, ←eq_sum_smul_of]
--   · rw [LinearMap.range_le_ker_iff]
--     ext x
--     change (diff₁ R G ≫ ε R G) (of x) = 0
--     rw [ε_comp_diff₁, Rep.zero_apply]

-- -- theorem exact_ε_diff₁' (v : leftRegular R G) (hv : ε R G v = 0) :
-- --   ∃ w : leftRegular R G, v = diff₁ R G w :=
-- -- by
-- --   let pre (g : G) : leftRegular R G :=
-- --     (of_sub_of_one_mem_range_diff₁ g).choose
-- --   have pre_spec (g : G) : diff₁ R G (pre g) = of g - of 1 :=
-- --     (of_sub_of_one_mem_range_diff₁ g).choose_spec
-- --   let S := (coeff v).support
-- --   use ∑ g ∈ S, coeff v g • pre g
-- --   simp only [map_sum, LinearMapClass.map_smul]
-- --   symm
-- --   trans ∑ x ∈ S, coeff v x • (of x - of 1)
-- --   · congr
-- --     ext x
-- --     congr
-- --     exact pre_spec x
-- --   · simp only [smul_sub, Finset.sum_sub_distrib]
-- --     symm
-- --     trans v - 0
-- --     · simp
-- --     · congr
-- --       · apply eq_sum_smul_of
-- --       · symm
-- --         rw [←Finset.sum_smul, ←ε_eq_sum_coeff, hv, zero_smul]

-- lemma coeff_diff₁_gen_mul (v : leftRegular R G) (g : G) :
--     coeff (diff₁ R G v) (gen * g) = coeff v (gen * g) - coeff v g :=
-- by
--   rw [diff₁, map_sub, Rep.sub_apply, map_sub, Finsupp.sub_apply]
--   congr 1
--   · congr
--     change ((leftRegularHomEquiv (leftRegular R G)).symm (of 1)) v = v
--     suffices : ((leftRegularHomEquiv (leftRegular R G)).symm (of 1)) = CategoryTheory.CategoryStruct.id _
--     · rw [this]
--       rfl
--     apply Hom.ext
--     rw [id_apply, ←hom_apply, leftRegularHomEquiv_symm_single, map_one, LinearMap.one_apply]
--   · convert coeff_ρReg_apply_self_mul gen v g
--     rw [leftRegularHomEquiv_symm_apply]
--     ext
--     rw [←hom_apply]
--     congr 3
--     apply leftRegularHom_eq_ρReg
--     rw [Subgroup.mem_center_iff]
--     intro g
--     obtain ⟨n,rfl⟩ := gen_spec g
--     group

-- lemma diff₁_apply_eq_zero {v : leftRegular R G} (hv : diff₁ R G v = (0 : leftRegular R G)) (g : G) :
--     coeff v g = coeff v 1 :=
-- by
--   have (h : G) : coeff v (gen * h) = coeff v h
--   · have := coeff_diff₁_gen_mul v h
--     rw [hv] at this
--     apply eq_of_sub_eq_zero this.symm
--   obtain ⟨n,rfl⟩ := gen_spec g
--   cases n
--   case intro.ofNat n =>
--     induction n with
--     | zero => simp
--     | succ n ih =>
--       simp only [Int.ofNat_eq_coe, zpow_natCast, Nat.cast_succ] at *
--       norm_cast at *
--       rw [pow_succ', this, ih]
--   case intro.negSucc n =>
--     induction n with
--     | zero =>
--       simp only [Nat.zero_eq, Int.reduceNegSucc, zpow_neg, zpow_one]
--       have := this (gen⁻¹)
--       rw [←this, mul_inv_cancel]
--     | succ n ih =>
--       have := this (gen ^ Int.negSucc n.succ)
--       rw [←this]
--       convert ih
--       rw [Nat.succ_eq_add_one, zpow_negSucc, zpow_negSucc, pow_succ,
--         mul_inv_rev, ←mul_assoc, mul_inv_cancel, one_mul]


-- end Rep.leftRegular


-- noncomputable section finiteCyclic

-- /-
-- In this section `G` is a finite cyclic group generated by an element `gen`.
-- -/


-- open Rep hiding of
-- open Classical Finsupp BigOperators leftRegular
-- open scoped CategoryTheory

-- variable [Fintype G]

-- section not_cyclic
-- omit [IsCyclic G]

-- variable (R G)
-- /--
-- `normElt` is the sum of the group elements, or equivalently
-- the element `G →₀ ℤ` all of whose values are `1`.
-- -/
-- def normElt : (leftRegular R G) := equivFunOnFinite.symm 1

-- variable {R G}

-- lemma normElt_def : normElt R G = equivFunOnFinite.symm 1 := rfl

-- lemma coe_coeff_normElt : (coeff (normElt R G) : G → R) = 1 := rfl

-- lemma coeff_normElt_apply (g : G) : coeff (normElt R G) g = 1 := rfl

-- lemma support_normElt [Nontrivial R] : (coeff (normElt R G) : G →₀ R).support = Fintype.elems :=
-- by
--   ext
--   rw [mem_support_iff, coeff_normElt_apply]
--   simp [Fintype.complete]


-- lemma normElt_eq_sum : normElt (G := G) (R := R) = ∑ g ∈ Fintype.elems, (of g) :=
-- by
--   by_cases hR : Nontrivial R
--   · rw [eq_sum_smul_of (normElt R G)]
--     simp
--     apply Finset.sum_congr
--     rw [support_normElt]
--     tauto
--   · by_contra h
--     have := nontrivial_of_ne _ _ h
--     rw [nontrivial_iff_nontrivial] at this
--     contradiction

-- @[simp] lemma ρReg_normElt (g : G) : ρReg g (normElt R G) = normElt R G :=
-- by
--   ext x
--   rw [coeff_ρReg_apply, coeff_normElt_apply, coeff_normElt_apply]

-- lemma leftRegularHom_normElt {A : Rep R G} (a : A) :
--     (leftRegularHom A a).hom (normElt R G) = ∑ g ∈ Fintype.elems, A.ρ g a :=
-- by
--   rw [normElt_eq_sum, map_sum]
--   apply Finset.sum_congr rfl
--   intros
--   apply leftRegularHom_of

-- lemma leftRegularHom_normElt_of (g : G) :
--     (leftRegularHom (leftRegular R G) (of g)) (normElt R G) = normElt R G:=
-- by
--   rw [←hom_apply, leftRegularHom_normElt, normElt_eq_sum]
--   let my_equiv : G ≃ G := {
--     toFun := (· * g)
--     invFun := (· * g⁻¹)
--     left_inv := by
--       intro
--       dsimp
--       group
--     right_inv := by
--       intro
--       dsimp
--       group
--   }
--   apply Finset.sum_equiv my_equiv
--   · simp [Fintype.complete]
--   · intro x _
--     rw [←ρReg, ρReg_apply_of]
--     rfl

-- variable (R G)
-- def diff₂ : leftRegular R G ⟶ leftRegular R G :=
--   leftRegularHom _ (normElt R G)
-- --notation "diff₂[" R "," G "]" => diff₂ (G := G) (R := R)

-- variable {R G}
-- @[simp] lemma diff₂_of (x : G) : diff₂ R G (of x) = normElt R G :=
-- by
--   rw [diff₂, leftRegularHom_of, ρReg_normElt]

-- end not_cyclic

-- instance : AddMonoidHomClass (Action.HomSubtype (ModuleCat R) G (leftRegular R G) (leftRegular R G))
--     ↑(leftRegular R G).V ↑(leftRegular R G).V where
--   map_add f := map_add f.val
--   map_zero f := map_zero f.val

-- @[simp] lemma diff₂_comp_diff₁ : diff₁ R G ≫ diff₂ R G = 0 :=
-- by
--   apply Hom.ext
--   rw [CategoryTheory.ConcreteCategory.comp_apply, diff₁_of_one, map_sub, diff₂_of, diff₂_of,
--     sub_self, Rep.zero_apply]


-- @[simp] lemma diff₁_comp_diff₂ : diff₂ R G ≫ diff₁ R G = 0 :=
-- by
--   apply Hom.ext -- `ext` would apply a weaker lemma here.
--   rw [Rep.comp_apply, diff₂_of, Rep.zero_apply, diff₁, map_sub, Rep.sub_apply]
--   simp only [ModuleCat.hom_sub, LinearMap.sub_apply, sub_eq_zero]
--   trans normElt R G
--   · apply leftRegularHom_normElt_of
--   · symm
--     apply leftRegularHom_normElt_of


-- variable (R) (G)

-- def myResolution : ChainComplex (Rep R G) ℕ where
--   X _       := leftRegular R G
--   d i j     := if (ComplexShape.down ℕ).Rel i j then
--                   (if Even i then diff₂ R G else diff₁ R G) else 0
--   d_comp_d' := by
--     intro i j k hij hjk
--     dsimp only [ComplexShape.down_Rel] at hij hjk ⊢
--     rw [←hij, ←hjk, if_pos rfl, if_pos rfl]
--     simp only [Nat.even_add_one]
--     split_ifs with h
--     · exact diff₂_comp_diff₁
--     · exact diff₁_comp_diff₂

-- variable {R} {G}

-- lemma myResolution_X {n : ℕ} : (myResolution R G).X n = leftRegular R G := rfl

-- @[simp] lemma myResolution_d {i j : ℕ} :
--     (myResolution R G).d i j = if (ComplexShape.down ℕ).Rel i j then
--     (if Even i then diff₂ R G else diff₁ R G) else 0 := rfl

-- -- @[simp] lemma myResolution_d' :
-- --     (myResolution R G).d (j + 1) j = if Even (j + 1) then diff₂ else diff₁ (R := R) (G := G) :=
-- -- by
-- --   simp


-- open IsCyclic

-- -- lemma diff₁_apply_eq_zero (hv : diff₁ v = (0 : leftRegular R G)) (g : G) : coeff v g = coeff v 1 :=
-- -- by
-- --   have (h : G) : coeff v (gen * h) = coeff v h
-- --   · have := coeff_diff₁_gen_mul v h
-- --     rw [hv] at this
-- --     apply eq_of_sub_eq_zero this.symm
-- --   obtain ⟨n,rfl⟩ := gen_spec g
-- --   cases n
-- --   case intro.ofNat n =>
-- --     induction n with
-- --     | zero => simp
-- --     | succ n ih =>
-- --       simp only [apply_eq_hom, Int.ofNat_eq_coe, zpow_natCast, Nat.cast_succ] at *
-- --       norm_cast at *
-- --       rw [pow_succ', this, ih]
-- --   case intro.negSucc n =>
-- --     induction n with
-- --     | zero =>
-- --       simp only [Nat.zero_eq, Int.reduceNegSucc, zpow_neg, zpow_one]
-- --       have := this (gen⁻¹)
-- --       rw [←this, mul_inv_cancel]
-- --     | succ n ih =>
-- --       have := this (gen ^ Int.negSucc n.succ)
-- --       rw [←this]
-- --       convert ih
-- --       group
-- --       congr


-- instance : MulActionHomClass (Action.HomSubtype (ModuleCat R) G (leftRegular R G) (leftRegular R G))
--     R ((fun X ↦ ↑X.V) (leftRegular R G)) ↑(leftRegular R G).V where
--   map_smulₛₗ f := map_smul f.val

-- theorem exact_diff₁_diff₂ (v : leftRegular R G) (hv : diff₁ R G v = (0: leftRegular R G)) :
--     ∃ w : leftRegular R G, diff₂ R G w = v :=
-- by
--   use coeff v 1 • of 1
--   ext
--   trans coeff v 1
--   · rw [map_smul]
--     simp only [map_smul, coe_smul, Pi.smul_apply, smul_eq_mul]
--     rw [diff₂_of, coeff_normElt_apply, mul_one]
--   · exact (diff₁_apply_eq_zero hv _).symm

-- theorem exact_diff₂_diff₁ :
--     LinearMap.ker (diff₂ R G).hom.hom ≤ LinearMap.range (diff₁ R G).hom.hom := by
--   intro v hv
--   rw [LinearMap.mem_ker, eq_sum_smul_of v, map_sum] at hv
--   simp only [LinearMapClass.map_smul] at hv
--   conv at hv => {
--     left
--     right
--     intro
--     rw [hom_apply, diff₂_of]
--   }
--   rw [←Finset.sum_smul] at hv
--   have : coeff ((∑ i ∈ (coeff v).support, (coeff v) i) • (normElt R G)) (1 : G) = 0
--   · rw [hv, map_zero, Finsupp.zero_apply]
--   simp only [map_smul, coe_smul, Pi.smul_apply, smul_eq_mul] at this
--   rw [coeff_normElt_apply, mul_one] at this
--   rw [←exact_ε_diff₁, LinearMap.mem_ker, hom_apply, ε_eq_sum_coeff, this]

-- /-
-- # TODO

-- Change this to use the Mathlib definition of exactness.
-- -/

-- --#check CategoryTheory.Exact
-- #check HomologicalComplex.ExactAt (myResolution R G) 1
-- #check CategoryTheory.ShortComplex.Exact

-- open CategoryTheory

-- variable (R G)

-- def myShortComplex₁ : ShortComplex (Rep R G) where
--   X₁ := leftRegular R G
--   X₂ := leftRegular R G
--   X₃ := leftRegular R G
--   zero := diff₂_comp_diff₁

-- def myShortComplex₂ : ShortComplex (Rep R G) where
--   X₁ := leftRegular R G
--   X₂ := leftRegular R G
--   X₃ := leftRegular R G
--   zero := diff₁_comp_diff₂

-- -- #synth HasForget₂ (Rep R G) Ab
-- #synth Abelian (Rep R G)
-- -- #synth ConcreteCategory (Rep R G)
-- -- #synth ConcreteCategory Ab


-- #synth HasForget₂ (Rep R G) (ModuleCat R)

-- #synth HasForget₂ (ModuleCat R) Ab

-- #check forget₂ (Rep R G) (ModuleCat R)

-- #check (myShortComplex₁ R G).map (forget₂ (Rep R G) (ModuleCat R))

-- instance : HasForget₂ (Rep R G) Ab where
--   forget₂ := forget₂ (Rep R G) (ModuleCat R) ⋙ forget₂ (ModuleCat R) Ab

-- instance : (forget₂ (Rep R G) Ab).Additive :=
--   Functor.instAdditiveComp (forget₂ (Rep R G) (ModuleCat R)) (forget₂ (ModuleCat R) Ab)

-- instance : (forget₂ (Rep R G) Ab).PreservesHomology :=
--   (forget₂ (Rep R G) (ModuleCat R) ⋙ forget₂ (ModuleCat R) Ab).preservesHomologyOfExact

-- lemma Exact₁ : (myShortComplex₁ R G).Exact :=
-- by
--   rw [ShortComplex.exact_iff_exact_map_forget₂]
--   rw [ShortComplex.ab_exact_iff_ker_le_range]
--   exact exact_diff₂_diff₁

-- lemma Exact₂ : (myShortComplex₂ R G).Exact := by
--   rw [ShortComplex.exact_iff_exact_map_forget₂]
--   rw [ShortComplex.ab_exact_iff_ker_le_range]
--   exact exact_diff₁_diff₂

-- example : HomologicalComplex.ExactAt (myResolution R G) 1 :=
-- by
--   rw [HomologicalComplex.exactAt_iff]
--   rw [ShortComplex.exact_iff_exact_map_forget₂]
--   rw [ShortComplex.ab_exact_iff_ker_le_range]
--   dsimp
--   split_ifs with h₁ h₂ h₃
--   · exact exact_diff₁_diff₂
--   · exfalso
--     simp at h₃
--   · exfalso
--     simp at h₂
--   · simp at h₁
--   · simp at h₁
--   · simp at h₁



-- example : (myResolution R G).homology 0 ≅ trivial R G R where
--   hom := {
--     hom := by
--       rw [HomologicalComplex.homology]

--       rw [ShortComplex.homology]

--       --convert ε (R :=R) (G := G)
--       sorry
--     comm := sorry
--   }
--   inv := sorry
--   hom_inv_id := sorry
--   inv_hom_id := sorry


-- variable (A : Rep R G)



-- def toSingle₀ : myResolution R G ⟶ (ChainComplex.single₀ _).obj (trivial R G R) :=
--   ((myResolution R G).toSingle₀Equiv (trivial R G R)).symm ⟨ε R G, ε_comp_diff₁⟩


-- #check groupCohomology A
-- #check groupCohomologyIsoExt
-- #check CategoryTheory.ProjectiveResolution (trivial R G R)

-- example : CategoryTheory.ProjectiveResolution (trivial R G R) where
--   complex := myResolution R G
--   projective _ := by
--     rw [myResolution_X]
--     infer_instance
--   hasHomology _ := inferInstance
--   π := toSingle₀ R G
--   quasiIso := by
--     let inv : trivial R G R ⟶ (myResolution R G).homology 0 := by
--       exact {
--         hom := by
--           apply ConcreteCategory.ofHom
--           exact {
--             toFun (r : R) := by

--               sorry
--             map_add' := sorry
--             map_smul' := sorry
--           }
--         comm := sorry
--       }

--     exact {
--       quasiIsoAt := by
--         intro i
--         cases i with
--         | zero =>
--           constructor
--           constructor

--           --rw [ShortComplex.quasiIso_iff]
--           sorry
--         | succ n =>
--           rw [quasiIsoAt_iff_exactAt]
--           · exact ChainComplex.exactAt_succ_single_obj (Rep.trivial R G R) n
--           · rw [HomologicalComplex.exactAt_iff, ShortComplex.exact_iff_exact_map_forget₂, ShortComplex.ab_exact_iff_ker_le_range]
--             simp only [ShortComplex.map_X₂, HomologicalComplex.shortComplexFunctor_obj_X₂,
--                 ShortComplex.map_X₃, HomologicalComplex.shortComplexFunctor_obj_X₃,
--                 ShortComplex.map_g, HomologicalComplex.shortComplexFunctor_obj_g, myResolution_d,
--                 ChainComplex.next_nat_succ, ComplexShape.down_Rel, ↓reduceIte, ShortComplex.map_X₁,
--                 HomologicalComplex.shortComplexFunctor_obj_X₁, ShortComplex.map_f,
--                 HomologicalComplex.shortComplexFunctor_obj_f, ChainComplex.prev]
--             by_cases hn : Even n
--             · rw [if_neg, if_pos]
--               exact exact_diff₁_diff₂
--               · rwa [Nat.even_add_one, Nat.even_add_one, not_not]
--               · rwa [Nat.even_add_one, not_not]
--             · rw [if_pos, if_neg]
--               exact exact_diff₂_diff₁
--               · rwa [Nat.even_add_one, Nat.even_add_one, not_not]
--               · rwa [Nat.even_add_one]
--     }
